// Copyright 2015 CoreOS, Inc.
// Copyright 2009 The Go Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package harness is similar to the standard Go testing package but is
// intended to support a larger variety of use cases and isn't dependent
// on the ``go test'' command.
//
// Similar to standard Go test framework, tests can be defined as
// stand-alone functions named with a ``Test'' prefix. Additionally this
// package provides a Group interface for grouping together tests.
// The biggest change from the Go test framework is the addition of a
// re-usable test Runner.
package harness

import (
	"bytes"
	"fmt"
	"runtime"
	"strings"
	"sync"
	"time"
)

// Similar to testing.T
type H struct {
	mu       sync.RWMutex // Guards output, failed, and skipped.
	output   []byte       // Output generated by test.
	failed   bool         // Test has failed.
	skipped  bool         // Test has been skipped.
	finished bool         // Test finished without panicking.

	start    time.Time
	duration time.Duration

	name string   // Name of test.
	test TestFunc // Test function to execute.
}

// decorate prefixes the string with the file and line of the call site
// and inserts the final newline if needed and indentation tabs for formatting.
func decorate(s string) string {
	_, file, line, ok := runtime.Caller(3) // decorate + log + public function.
	if ok {
		// Truncate file name at last file name separator.
		if index := strings.LastIndex(file, "/"); index >= 0 {
			file = file[index+1:]
		} else if index = strings.LastIndex(file, "\\"); index >= 0 {
			file = file[index+1:]
		}
	} else {
		file = "???"
		line = 1
	}
	buf := new(bytes.Buffer)
	// Every line is indented at least one tab.
	buf.WriteByte('\t')
	fmt.Fprintf(buf, "%s:%d: ", file, line)
	lines := strings.Split(s, "\n")
	if l := len(lines); l > 1 && lines[l-1] == "" {
		lines = lines[:l-1]
	}
	for i, line := range lines {
		if i > 0 {
			// Second and subsequent lines are indented an extra tab.
			buf.WriteString("\n\t\t")
		}
		buf.WriteString(line)
	}
	buf.WriteByte('\n')
	return buf.String()
}

// Fail marks the function as having failed but continues execution.
func (h *H) Fail() {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.failed = true
}

// Failed reports whether the function has failed.
func (h *H) Failed() bool {
	h.mu.RLock()
	defer h.mu.RUnlock()
	return h.failed
}

// FailNow marks the function as having failed and stops its execution.
// Execution will continue at the next test or benchmark.
// FailNow must be called from the goroutine running the
// test or benchmark function, not from other goroutines
// created during the test. Calling FailNow does not stop
// those other goroutines.
func (h *H) FailNow() {
	h.Fail()

	// Calling runtime.Goexit will exit the goroutine, which
	// will run the deferred functions in this goroutine,
	// which will eventually run the deferred lines in tRunner,
	// which will signal to the test loop that this test is done.
	h.finished = true
	runtime.Goexit()
}

// log generates the output. It's always at the same stack depth.
func (h *H) log(s string) {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.output = append(h.output, decorate(s)...)
}

// Log formats its arguments using default formatting, analogous to Println,
// and records the text in the error log. For tests, the text will be printed only if
// the test fails or the -test.v flag is set. For benchmarks, the text is always
// printed to avoid having performance depend on the value of the -test.v flag.
func (h *H) Log(args ...interface{}) {
	h.log(fmt.Sprintln(args...))
}

// Logf formats its arguments according to the format, analogous to Printf,
// and records the text in the error log. For tests, the text will be printed only if
// the test fails or the -test.v flag is set. For benchmarks, the text is always
// printed to avoid having performance depend on the value of the -test.v flag.
func (h *H) Logf(format string, args ...interface{}) {
	h.log(fmt.Sprintf(format, args...))
}

// Error is equivalent to Log followed by Fail.
func (h *H) Error(args ...interface{}) {
	h.log(fmt.Sprintln(args...))
	h.Fail()
}

// Errorf is equivalent to Logf followed by Fail.
func (h *H) Errorf(format string, args ...interface{}) {
	h.log(fmt.Sprintf(format, args...))
	h.Fail()
}

// Fatal is equivalent to Log followed by FailNow.
func (h *H) Fatal(args ...interface{}) {
	h.log(fmt.Sprintln(args...))
	h.FailNow()
}

// Fatalf is equivalent to Logf followed by FailNow.
func (h *H) Fatalf(format string, args ...interface{}) {
	h.log(fmt.Sprintf(format, args...))
	h.FailNow()
}

// Skip is equivalent to Log followed by SkipNow.
func (h *H) Skip(args ...interface{}) {
	h.log(fmt.Sprintln(args...))
	h.SkipNow()
}

// Skipf is equivalent to Logf followed by SkipNow.
func (h *H) Skipf(format string, args ...interface{}) {
	h.log(fmt.Sprintf(format, args...))
	h.SkipNow()
}

// SkipNow marks the test as having been skipped and stops its execution.
// Execution will continue at the next test or benchmark. See also FailNow.
// SkipNow must be called from the goroutine running the test, not from
// other goroutines created during the test. Calling SkipNow does not stop
// those other goroutines.
func (h *H) SkipNow() {
	h.skip()
	h.finished = true
	runtime.Goexit()
}

func (h *H) skip() {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.skipped = true
}

// Skipped reports whether the test was skipped.
func (h *H) Skipped() bool {
	h.mu.RLock()
	defer h.mu.RUnlock()
	return h.skipped
}

// Output returns all logged messages from the test.
func (h *H) Output() []byte {
	h.mu.Lock()
	defer h.mu.Unlock()
	return h.output
}

// Duration returns the time the test took to execute.
func (h *H) Duration() time.Duration {
	return h.duration
}

// Name returns the test name H wraps.
func (h *H) Name() string {
	return h.name
}

// Start launches the test in a new goroutine. When the test completes
// the test harness will be passed back over the returned channel.
func (h *H) Start() <-chan *H {
	fmt.Printf("=== RUN   %s\n", h.name)
	signal := make(chan *H)
	go h.run(signal)
	return signal
}

func (h *H) run(signal chan<- *H) {
	// When this goroutine is done, either because h.test(h)
	// returned normally or because a test failure triggered
	// a call to runtime.Goexit, record the duration and send
	// a signal saying that the test is done.
	defer func() {
		h.duration = time.Since(h.start)
		// If the test panicked, print any test output before dying.
		err := recover()
		if !h.finished && err == nil {
			err = fmt.Errorf("test executed panic(nil) or runtime.Goexit")
		}
		if err != nil {
			h.Fail()
			h.report()
			panic(err)
		}
		signal <- h
	}()

	h.start = time.Now()
	h.test(h)
	h.finished = true
}

func (h *H) report() {
	var state string
	if h.Failed() {
		state = "FAIL"
	} else if h.Skipped() {
		state = "SKIP"
	} else {
		state = "PASS"
	}
	fmt.Printf("--- %s: %s (%.2fs)\n%s",
		state, h.name, h.duration.Seconds(), h.output)
}
